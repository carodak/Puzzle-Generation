# -*- coding: utf-8 -*-
"""ExecutiveFunctioning-PCG-v2-0-0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E2XRSY2GzoUSpNBjnZzsgV9vv5mSneMT

Puzzle generation code for the Executive Functioning Task(https://pavlovia.org/katielavigne/executive-function)

# Executive Functioning task statement

---



1.        Puzzle Setup: The game board has a grid with colored blocks arranged in a specific pattern.
The blocks are initially located in the last row of the grid, either alone or on top of another block.
There are no blocks that end up without a block beneath them (except for the last row of the grid).
No more than 2 blocks of the same color are horizontally or vertically aligned. Each colour must have at least 3 blocks.
2.        Game Play: The player's goal is to remove all blocks from the grid in as few moves as possible.
3.        Available Moves:
1.        a. Simple Move: The player can move a block one cell to the left or right if the target cell is empty.
2.        b. Exchange: The player can swap a block with the one to its left or right, if the target cell is occupied.
4.        Elimination Rule: If more than 2 blocks of the same color are aligned horizontally or vertically, then all aligned blocks disappear.
5.        Falling Rule: If there is no block beneath a block, then the block falls until it is supported by another block or it reaches the bottom row of the grid.
6.        Winning Condition: The player wins when all blocks are removed from the grid in a minimum number of moves. Wrong moves can cause the player to fail to clear all the blocks.

# Choose the batch generation settings
"""

blocks_range = (6, 13)
colors_range = (2, 4)
batch_grid_size = (12, 6)
colors_blocks = ['blue', 'red', 'gray', 'yellow']
nb_moves = 5
stack_probability = 0.75
##blocks_gap = 1

"""# Implement the Puzzle Setup

Utility functions
"""

!pip3 install --no-index matplotlib

# Will randomly assign a color to each block
import logging
logging.getLogger().setLevel(logging.INFO)

def assign_blocks_per_color(nb_blocks, colors):
  blocks_per_color = []
  nb_blocks_to_assign = nb_blocks

  for i in range(0, len(colors)):
    blocks_per_color.append([colors[i], 3])
    nb_blocks_to_assign = nb_blocks_to_assign-3

  while nb_blocks_to_assign != 0:
    random_color = random.choice(colors) # select color
    random_blocks = random.randint(0, nb_blocks_to_assign)
    blocks_per_color = [[color, value + random_blocks] if color == random_color else [color, value] for color, value in blocks_per_color]
    nb_blocks_to_assign = nb_blocks_to_assign-random_blocks
  return blocks_per_color

# Some utilities function
def sort_blocks_by_rows(set_blocks):
  set_blocks = dict(sorted(set_blocks.items(), key=lambda x: x[0]))
  #logging.debug("Sorted blocks by row: ", set_blocks)
  return set_blocks

def sort_blocks_by_columns(set_blocks):
  set_blocks = dict(sorted(set_blocks.items(), key=lambda x: x[0][1]))
  #logging.debug("Sorted blocks by column: ", set_blocks)
  return set_blocks

#assign_blocks_per_color(nb_blocks=nb_blocks, colors=colors)


class Block:
  """Block Class: This class represents the individual blocks on the game board. It contains the color of the block and methods to set and get the color."""
  def __init__(self, color):
    self.color = color

  def set_color(self, color):
    self.color = color

  def get_color(self):
    return self.color

  def __str__(self):
    return f"Colored {self.color} block"

  def __repr__(self):
    return f"<Color: {self.color}>"

import math
import matplotlib.pyplot as plt
import matplotlib as mpl
import sys, random
mpl.rcParams['figure.max_open_warning'] = 50  # Increase the maximum number of warnings
from matplotlib.patches import Rectangle, FancyArrowPatch
from matplotlib import colors

class GridInitializer:
    """GridInitializer Class: This class is responsible for handling the setup of the game board, including generating the initial configuration of blocks.
    """
    def __init__(self, grid_size, nb_blocks, colors, min_nb_moves, stack_probability, blocks_gap):
        """
        Initialize the GridInitializer.

        Args:
            grid_size (tuple): Size of the grid as (rows, columns).
            nb_blocks (int): Number of blocks to place.
            colors (list): List of block colors.
            min_nb_moves (int): Minimum number of moves to solve.
            stack_probability (float): Probability of stacking blocks.
            blocks_gap (int): Minimum gap between blocks in the same row.
        """
        self.grid_size = grid_size
        self.nb_blocks = nb_blocks
        self.colors = colors
        self.set_blocks = {}
        self.min_nb_moves = min_nb_moves
        self.stack_probability = stack_probability
        self.blocks_gap = blocks_gap

    def is_valid_position(self, row, col):
        """
        Check if a position is within the grid bounds.

        Args:
            row (int): Row index.
            col (int): Column index.

        Returns:
            bool: True if position is valid, False otherwise.
        """
        if row < 0 or row >= self.grid_size[0] or col < 0 or col >= self.grid_size[1]:
            return False
        return True

    def is_block_present(self, row, col):
        """
        Check if a block is present at the given position.

        Args:
            row (int): Row index.
            col (int): Column index.

        Returns:
            list: [True, color] if block is present, [False, None] otherwise.
        """
        if self.is_valid_position(row, col):
            if (row, col) in self.set_blocks:
                block = self.set_blocks[(row, col)]
                block_color = block.color
            else:
                block_color = None
            return [block_color is not None, block_color]
        return [False, None]

    def is_similar_block(self, row, col, color):
        """
        Check if a block of the same color is present at the given position.

        Args:
            row (int): Row index.
            col (int): Column index.
            color (str): Color to check.

        Returns:
            bool: True if a similar block is present, False otherwise.
        """
        block_present = self.is_block_present(row, col)
        if self.is_valid_position(row, col) and block_present[0] and block_present[1] == color:
            return True

    def check_valid_placement(self, row, col, color):
        """
        Check if placing a block at the given position is valid according to the rules (no matches are allowed during initial setup).

        Args:
            row (int): Row index.
            col (int): Column index.
            color (str): Color of the block.

        Returns:
            bool: True if placement is valid, False otherwise.
        """
        if self.is_similar_block(row + 1, col, color) and self.is_similar_block(row + 2, col, color):
            return False
        if self.is_similar_block(row, col-1, color) and self.is_similar_block(row, col+1, color):
            return False
        if self.is_similar_block(row, col-1, color) and self.is_similar_block(row, col-2, color):
            return False
        if self.is_similar_block(row, col+1, color) and self.is_similar_block(row, col+2, color):
            return False
        return True

    def get_highest_positions(self):
        """
        Get the highest (topmost) block positions for each column.

        Returns:
            list: List of (row, col) tuples representing the highest block in each column.
        """
        highest_positions = {}
        for position in self.set_blocks:
            row, col = position
            if col not in highest_positions or row < highest_positions[col][0]:
                highest_positions[col] = (row, col)
        highest_block_positions = list(highest_positions.values())
        return highest_block_positions

    def select_random_highest_position(self):
        """
        Select a random position above the highest block in a random column or return an empty position with a gap.

        Returns:
            tuple: (row, col) position above a random highest block, or an empty position with gap if none found.
        """
        highest_block_positions = self.get_highest_positions()
        highest_block_positions_filtered = [(row, col) for row, col in highest_block_positions if row != 0]
        if not highest_block_positions_filtered:
            return self.select_empty_positions_with_gap()
        random_position = random.choice(highest_block_positions_filtered)
        return (random_position[0]-1,random_position[1])

    def get_empty_positions_with_gap(self):
        """
        Get empty positions in the bottomost row that respect the minimum gap between blocks.

        Returns:
            list: List of (row, col) tuples for valid empty positions.
        """
        last_row = self.grid_size[0] - 1
        empty_positions_with_gap = []
        highest_positions = self.get_highest_positions()

        for row, col in highest_positions:
            adjacent_cols = [col + self.blocks_gap, col + self.blocks_gap + 1, col - self.blocks_gap, col - self.blocks_gap - 1]
            adjacent_cols = [adj_col for adj_col in adjacent_cols if adj_col >= 0 and adj_col < self.grid_size[1]]

            for adj_col in adjacent_cols:
                adjacent_position = (last_row, adj_col)
                if adjacent_position not in self.set_blocks:
                    empty_positions_with_gap.append(adjacent_position)

        return empty_positions_with_gap

    def select_empty_positions_with_gap(self):
        """
        Select a random empty position in the last row that respects the minimum gap.

        Returns:
            tuple: (row, col) position.
        """
        empty_positions_with_gap = self.get_empty_positions_with_gap()
        if not empty_positions_with_gap:
            return self.select_random_highest_position()
        random_position = random.choice(empty_positions_with_gap)
        return random_position

    def initialize_grid(self):
        """
        Initialize the grid with blocks according to the rules and constraints.
        
        The method performs the following steps:
          - Determines the number of blocks to place per color using `assign_blocks_per_color`.
          - Creates a list of blocks to place, respecting the color distribution.
          - Iteratively places each block in the grid, either stacking on existing blocks or
            placing in empty positions that respect minimum spacing (gap) constraints.
          - The first block is placed near the center top of the grid.
          - For subsequent blocks, the placement is either stacked on top of existing blocks (with a
            probability defined by `stack_probability`) or placed in valid empty positions.
          - Each potential placement is validated by `check_valid_placement` to avoid rule violations (e.g., no immediate matches).
          - Once placed, blocks are recorded in `self.set_blocks` with their positions as keys.
          - Finally, `self.set_blocks` is sorted by row to maintain a consistent order.

        This process ensures the initial puzzle grid respects the game's placement rules
        and sets up a valid starting configuration for the puzzle.

        Returns:
            None
        """
        blocks_per_color = assign_blocks_per_color(self.nb_blocks, self.colors)
        blocks_to_place = [color for color, count in blocks_per_color for i in range(count)]
        while blocks_to_place:
            placed = False
            while not(placed):
                stacked = False
                if random.random() < self.stack_probability:
                    stacked = True
                random_block_index = random.randrange(len(blocks_to_place))
                random_block_color = blocks_to_place[random_block_index]
                if not self.set_blocks:
                    random_column_grid = math.floor(self.grid_size[1]/2)
                    selected_row = self.grid_size[0]-1
                elif not stacked:
                    random_position = self.select_empty_positions_with_gap()
                    random_column_grid = random_position[1]
                    selected_row = random_position[0]
                if stacked and self.set_blocks:
                    random_position = self.select_random_highest_position()
                    random_column_grid = random_position[1]
                    selected_row = random_position[0]

                if self.check_valid_placement(selected_row, random_column_grid, random_block_color):
                    block = Block(random_block_color)
                    self.set_blocks[(selected_row, random_column_grid)] = block
                    placed = True
            blocks_to_place.pop(random_block_index)
        self.set_blocks = sort_blocks_by_rows(self.set_blocks)

    def change_set_blocks(self, set_blocks):
        """
        Change the current set of blocks to a new configuration.

        Args:
            set_blocks (dict): New set of blocks.
        """
        self.set_blocks = set_blocks

    @staticmethod
    def init_graphical_grid(set_blocks, grid_size):
        """
        Create a graphical representation of the puzzle grid using matplotlib.

        This method builds a 2D color grid from the set of placed blocks, then draws it using 
        matplotlib by rendering each cell as a colored rectangle. The Y-axis is flipped so that 
        row 0 appears at the bottom, consistent with a bottom-up grid orientation.

        Args:
            set_blocks (dict): Dictionary mapping (row, col) positions to Block objects. Each block
                                contains a `color` attribute used for rendering.
            grid_size (tuple): A (rows, columns) tuple indicating the dimensions of the grid.

        Returns:
            tuple: (fig, ax, grid)
                - fig (matplotlib.figure.Figure): The matplotlib figure object.
                - ax (matplotlib.axes.Axes): The matplotlib axis with rendered grid.
                - grid (list of lists): 2D list of cell colors representing the grid state.
        """
        grid = [['white' for _ in range(grid_size[1])] for _ in range(grid_size[0])]
        for position, block in set_blocks.items():
            row, col = position
            grid[row][col] = block.color

        fig, ax = plt.subplots()
        ax.axis('off')
        for row in range(grid_size[0]):
            for col in range(grid_size[1]):
                color = grid[row][col]
                rect = plt.Rectangle((col, grid_size[0] - row - 1), 1, 1, facecolor=color, edgecolor='black')
                ax.add_patch(rect)

        return fig, ax, grid

    def print_initial_grid(self):
        """
        Print and display the initial grid using matplotlib.
        """
        fig, ax, grid = GridInitializer.init_graphical_grid(self.set_blocks, self.grid_size)
        ax.set_aspect('equal')
        ax.set_xlim(-0.5, self.grid_size[1] + 0.5)
        ax.set_ylim(-0.5, self.grid_size[0] + 0.5)
        print("Here is the randomly-created Puzzle: ")
        plt.show()
        print("\nOr a shorter representation: \n", self.set_blocks)

from collections import Counter, deque
class PuzzleLogic():
    """
    PuzzleLogic Class: Contains methods responsible for the game's core logic.
    This includes checking for block elimination, enforcing gravity rules (making blocks fall down after elimination),
    and performing player moves (e.g., swapping two adjacent blocks).
    """
    def __init__(self):
        """Initialize the PuzzleLogic class."""
        return

    def check_all_available_moves(self, current_position, color, set_blocks, grid_size):
        """
        Check all possible moves for a block at the given position.

        Args:
            current_position (tuple): (row, col) position of the block.
            color (str): Color of the block.
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            dict: Dictionary with possible moves as keys and booleans as values.
        """
        possible_moves = {
            'move_left': self.can_move_left(current_position, set_blocks),
            'move_right': self.can_move_right(current_position, set_blocks, grid_size),
            'exchange_left': self.can_exchange_left(current_position, color, set_blocks),
            'exchange_right': self.can_exchange_right(current_position, color, set_blocks, grid_size)
        }
        return possible_moves

    def can_move_left(self, position, set_blocks):
        """
        Check if a block can move left to an unoccupied space.

        Args:
            position (tuple): (row, col) position of the block.
            set_blocks (dict): Current set of blocks.

        Returns:
            bool: True if the block can move left, False otherwise.
        """
        row, col = position
        if col > 0:
            left_position = (row, col - 1)
            return left_position not in set_blocks
        return False

    def can_move_right(self, position, set_blocks, grid_size):
        """
        Check if a block can move right to an unoccupied space.

        Args:
            position (tuple): (row, col) position of the block.
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            bool: True if the block can move right, False otherwise.
        """
        row, col = position
        if col < grid_size[1] - 1:
            right_position = (row, col + 1)
            return right_position not in set_blocks
        return False

    def can_exchange_left(self, position, color, set_blocks):
        """
        Check if a block can exchange with the block to its left.

        Args:
            position (tuple): (row, col) position of the block.
            color (str): Color of the block.
            set_blocks (dict): Current set of blocks.

        Returns:
            bool: True if the block can exchange left, False otherwise.
        """
        row, col = position
        if col > 0:
            left_position = (row, col - 1)
            return left_position in set_blocks and color != set_blocks[left_position].color
        return False

    def can_exchange_right(self, position, color, set_blocks, grid_size):
        """
        Check if a block can exchange with the block to its right.

        Args:
            position (tuple): (row, col) position of the block.
            color (str): Color of the block.
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            bool: True if the block can exchange right, False otherwise.
        """
        row, col = position
        if col < grid_size[1] - 1:
            right_position = (row, col + 1)
            return right_position in set_blocks and color != set_blocks[right_position].color
        return False

    def update_block(self, old_position, new_position, set_blocks):
        """
        Update the position of a block in the set_blocks dictionary.

        Args:
            old_position (tuple): Previous (row, col) position.
            new_position (tuple): New (row, col) position.
            set_blocks (dict): Current set of blocks.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        saved_block = set_blocks.pop(old_position)
        set_blocks[new_position] = saved_block
        set_blocks = sort_blocks_by_rows(set_blocks)
        return set_blocks

    def exchange_block(self, first_position, second_position, set_blocks):
        """
        Exchange two blocks in the set_blocks dictionary.

        Args:
            first_position (tuple): (row, col) of the first block.
            second_position (tuple): (row, col) of the second block.
            set_blocks (dict): Current set of blocks.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        block_1 = set_blocks[first_position]
        block_2 = set_blocks[second_position]
        set_blocks[first_position] = block_2
        set_blocks[second_position] = block_1
        set_blocks = sort_blocks_by_rows(set_blocks)
        return set_blocks

    def has_matches(self, set_blocks):
        """
        Check if there are any matches (3 or more aligned blocks of the same color).

        Args:
            set_blocks (dict): Current set of blocks.

        Returns:
            bool: True if matches exist, False otherwise.
        """
        return bool(self.find_matches(set_blocks))

    def find_matches(self, set_blocks):
        """
        Find all matches (3 or more aligned blocks of the same color).

        Args:
            set_blocks (dict): Current set of blocks.

        Returns:
            set: Set of positions where matches are found.
        """
        matches = set()

        matches |= self.find_matches_by_rows(set_blocks)
        matches |= self.find_matches_by_columns(set_blocks)

        return matches

    def find_matches_by_rows(self, set_blocks):
        """
        Find all horizontal matches in the set_blocks.

        Args:
            set_blocks (dict): Current set of blocks.

        Returns:
            set: Set of positions where horizontal matches are found.
        """
        matches = set()

        set_blocks_row = sort_blocks_by_rows(set_blocks)
        matches |= self.find_matches_in_iterator(set_blocks_row.items(), is_same_row=True)

        return matches

    def find_matches_by_columns(self, set_blocks):
        """
        Find all vertical matches in the set_blocks.

        Args:
            set_blocks (dict): Current set of blocks.

        Returns:
            set: Set of positions where vertical matches are found.
        """
        matches = set()

        set_blocks_column = sort_blocks_by_columns(set_blocks)
        matches |= self.find_matches_in_iterator(set_blocks_column.items(), is_same_row=False)

        return matches

    def find_matches_in_iterator(self, set_blocks, is_same_row):
        """
        Helper function to find matches in an iterator (row or column).

        Args:
            set_blocks (iterator): Iterator over set_blocks items.
            is_same_row (bool): True for row, False for column.

        Returns:
            set: Set of positions where matches are found.
        """
        matches = set()
        tmp_matches = set()
        nb_aligned = 1

        try:
            iterator = iter(set_blocks)
            (position, block) = next(iterator)
            while True:
                (next_position, next_block) = next(iterator)
                if self.is_aligned(position, next_position, block, next_block, is_same_row):
                    nb_aligned += 1
                    tmp_matches.add(position)
                    tmp_matches.add(next_position)
                else:
                    nb_aligned = 1
                    tmp_matches = set()

                if nb_aligned >= 3:
                    matches |= tmp_matches

                position, block = next_position, next_block

        except StopIteration:
            pass

        return matches

    def delete_matches(self, set_blocks, matches):
        """
        Delete all matched blocks from the set_blocks.

        Args:
            set_blocks (dict): Current set of blocks.
            matches (set): Set of positions to delete.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        new_set_blocks = set_blocks.copy()
        for key in matches:
            if key in new_set_blocks:
                del new_set_blocks[key]
        return new_set_blocks

    def is_aligned(self, position, next_position, block, next_block, is_same_row):
        """
        Check if two blocks are aligned and of the same color.

        Args:
            position (tuple): (row, col) of the first block.
            next_position (tuple): (row, col) of the second block.
            block (Block): First block.
            next_block (Block): Second block.
            is_same_row (bool): True for row, False for column.

        Returns:
            bool: True if aligned and same color, False otherwise.
        """
        if is_same_row:
            return position[0] == next_position[0] and position[1] == next_position[1] - 1 and block.color == next_block.color
        else:
            return position[1] == next_position[1] and position[0] == next_position[0] - 1 and block.color == next_block.color

    def has_gravity(self, set_blocks, grid_size):
        """
        Check if any block can fall due to gravity.

        Args:
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            bool: True if gravity applies, False otherwise.
        """
        return bool(self.apply_gravity(set_blocks, grid_size) != set_blocks)

    def apply_gravity(self, set_blocks, grid_size):
        """
        Apply gravity to all blocks (make unsupported blocks fall).

        For each block in the grid (processed from bottom to top), this function checks whether
        there is empty space directly beneath it. If so, it allows the block to fall vertically 
        until it lands on either another block or the bottom of the grid.

        Args:
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            dict: Updated set_blocks dictionary after gravity.
        """
        new_set_blocks = set_blocks.copy()
        for position in reversed(set_blocks):
            row, col = position
            underneath_position = (row + 1, col)

            while underneath_position[0] < grid_size[0] and underneath_position not in new_set_blocks:
              underneath_position = (underneath_position[0] + 1, underneath_position[1])

            new_position = (underneath_position[0] - 1, underneath_position[1])
            if new_position != position:
              new_set_blocks = self.update_block(position, new_position, new_set_blocks)
        return new_set_blocks

    def apply_gravity_and_eliminate_matches(self, set_blocks, grid_size):
        """
        Apply gravity and eliminate matches repeatedly until stable.

        Args:
            set_blocks (dict): Current set of blocks.
            grid_size (tuple): Size of the grid.

        Returns:
            dict: Updated set_blocks dictionary after gravity and elimination.
        """
        new_set_blocks = set_blocks.copy()
        while True:
            new_set_blocks_before = new_set_blocks.copy()
            new_set_blocks = self.apply_gravity(new_set_blocks, grid_size)
            new_set_blocks = self.delete_matches(new_set_blocks,self.find_matches(new_set_blocks))
            if new_set_blocks == new_set_blocks_before:
                break
        return new_set_blocks

    def make_move(self, move_type, position, set_blocks):
        """
        Perform a move (either a simple shift or an exchange) on a given block in the grid (set_blocks).

        Args:
            move_type (str): Type of move ('move_left', 'move_right', etc.).
            position (tuple): (row, col) of the block to move.
            set_blocks (dict): Current set of blocks.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        if move_type == "move_left":
            set_blocks = self.make_simple_move(position, "left", set_blocks)
        elif move_type == "move_right":
            set_blocks = self.make_simple_move(position, "right", set_blocks)
        elif move_type == "exchange_left":
            set_blocks = self.make_exchange_move(position, "left", set_blocks)
        elif move_type == "exchange_right":
            set_blocks = self.make_exchange_move(position, "right", set_blocks)
        return set_blocks

    def make_simple_move(self, position, direction, set_blocks):
        """
        Perform a simple move (left or right) for a given block.

        Args:
            position (tuple): (row, col) of the block.
            direction (str): 'left' or 'right'.
            set_blocks (dict): Current set of blocks.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        if direction == "left":
          new_position = (position[0], position[1]-1)
          set_blocks = self.update_block(position, new_position, set_blocks)
        elif direction == "right":
          new_position = (position[0], position[1]+1)
          set_blocks = self.update_block(position, new_position, set_blocks)
        return set_blocks

    def make_exchange_move(self, position, direction, set_blocks):
        """
        Perform an exchange move (left or right) for a given block.

        Args:
            position (tuple): (row, col) of the block.
            direction (str): 'left' or 'right'.
            set_blocks (dict): Current set of blocks.

        Returns:
            dict: Updated set_blocks dictionary.
        """
        if direction == "left":
          new_position = (position[0], position[1]-1)
          set_blocks = self.exchange_block(position, new_position, set_blocks)
        elif direction == "right":
          new_position = (position[0], position[1]+1)
          set_blocks = self.exchange_block(position, new_position, set_blocks)
        return set_blocks

    def get_game_state(self, set_blocks, colors):
        """
        Get the current game state.

        Args:
            set_blocks (dict): Current set of blocks.
            colors (list): List of block colors.

        Returns:
            int: 3 for victory, 2 for defeat, 1 for in progress.
        """
        if not set_blocks:
          return 3
        elif not self.has_valid_block_color_counts(set_blocks, colors):
          return 2
        else:
          return 1

    def has_valid_block_color_counts(self, set_blocks, colors):
        """
        Check if all colors have at least 3 blocks.

        Args:
            set_blocks (dict): Current set of blocks.
            colors (list): List of block colors.

        Returns:
            bool: True if valid, False otherwise.
        """
        color_counts = self.count_block_colors(set_blocks)
        for color in colors:
            if color_counts[color] == 1 or color_counts[color] == 2:
                return False
            else:
                return True

    def count_block_colors(self, set_blocks):
        """
        Count the number of blocks for each color.

        Args:
            set_blocks (dict): Current set of blocks.

        Returns:
            Counter: Counter object with color counts.
        """
        color_counts = Counter(block.color for block in set_blocks.values())
        return color_counts

class BFSSolver:
    """
    BFSSolver Class: Uses Breadth-First Search (BFS) to simulate and solve the puzzle.
    Takes an instance of the game logic class as input.
    """
    def __init__(self, grid_initializer, puzzle_logic):
        """
        Initialize the BFSSolver.

        Args:
            grid_initializer (GridInitializer): The grid initializer instance.
            puzzle_logic (PuzzleLogic): The puzzle logic instance.
        """
        self.grid_initializer = grid_initializer
        self.puzzle_logic = puzzle_logic

    def perform_all_blocks_moves(self):
        """
        Perform BFS to find a solution for the puzzle.

        Returns:
            tuple: (is_solvable (bool), solution (dict))
        """
        min_moves_to_solve = self.grid_initializer.min_nb_moves
        initial_set_blocks = self.grid_initializer.set_blocks.copy()
        grid_size = self.grid_initializer.grid_size
        colors = self.grid_initializer.colors

        queue = deque()
        current_round = 0
        initial_node = {
            "set_blocks_history": [initial_set_blocks],
            "moves_types_history": [],
            "moved_blocks_history" : [],
            "rounds_number_history": [1],
            "puzzle_states_history" : [1]
        }
        queue.append(initial_node)

        #print(f"\n\n..::SOLVER STEP:.. Checking if the puzzle has a solution in {min_moves_to_solve} moves\n")
        while queue:
          current_item = queue.popleft()

          set_blocks = current_item["set_blocks_history"][-1].copy()
          current_round = current_item["rounds_number_history"][-1]
          if current_round > min_moves_to_solve:
            break
          puzzle_state = current_item["puzzle_states_history"][-1]

          #logging.debug(f"\n\nWe are simulating round: {current_round} and the following set of blocks: {set_blocks} \n")

          if puzzle_state == 1:
            is_solvable, solution = self.process_possible_moves(set_blocks, current_item, current_round, grid_size, colors, queue)
            if is_solvable:
              return True, solution
        print(f"Did not find a solution in {current_round-1} moves. See the queue")
        return False, {}

    def process_possible_moves(self, set_blocks, current_item, current_round, grid_size, colors, queue):
        """
        Process all possible moves for the current state.

        Args:
            set_blocks (dict): Current set of blocks.
            current_item (dict): Current BFS node.
            current_round (int): Current round number.
            grid_size (tuple): Size of the grid.
            colors (list): List of block colors.
            queue (deque): BFS queue.

        Returns:
            tuple: (is_solvable (bool), solution (dict))
        """
        for position, block in set_blocks.items():
          possible_moves = self.puzzle_logic.check_all_available_moves(position, block.color, set_blocks, grid_size)
          for move_type in ['move_left', 'move_right', 'exchange_left', 'exchange_right']:
            updated_blocks = set_blocks.copy()
            if possible_moves[move_type]:
              updated_blocks = self.puzzle_logic.make_move(move_type, position, updated_blocks)
              updated_blocks = self.puzzle_logic.apply_gravity_and_eliminate_matches(updated_blocks, grid_size)
              state = self.puzzle_logic.get_game_state(updated_blocks, colors)

              next_node = {
                        "set_blocks_history": current_item["set_blocks_history"] + [updated_blocks],
                        "moves_types_history": current_item["moves_types_history"] + [move_type],
                        "moved_blocks_history" : current_item["moved_blocks_history"] + [position],
                        "rounds_number_history": current_item["rounds_number_history"] + [current_round+1],
                        "puzzle_states_history" : current_item["puzzle_states_history"] + [state]
              }
              queue.append(next_node)
              if state == 3:
                solution = self.process_solution(next_node, current_round)
                return True, solution
        return False, {}

    def process_solution(self, solved_puzzle_dict, current_round):
        """
        Process and return the solution path.

        Args:
            solved_puzzle_dict (dict): Dictionary containing the solution path.
            current_round (int): Number of rounds taken to solve.

        Returns:
            dict: The solution dictionary.
        """
        solved_puzzle_dict["moves_types_history"].append('')
        solved_puzzle_dict["moved_blocks_history"].append(())

        print(f"Found a solution: {solved_puzzle_dict['set_blocks_history']} in {current_round} moves \n")
        return solved_puzzle_dict

    @staticmethod
    def print_history(solved_puzzle_dict, grid_size, show, ax=None):
        """
        Print and display the history of moves for a solved puzzle.

        Args:
            solved_puzzle_dict (dict): Solution dictionary with move history.
            grid_size (tuple): Size of the grid.
            show (bool): Whether to display the plot.
            ax (matplotlib.axes.Axes, optional): Axis to plot on.

        Returns:
            None
        """
        set_blocks_history = solved_puzzle_dict["set_blocks_history"]
        moved_blocks_history = solved_puzzle_dict["moved_blocks_history"]
        moves_types_history = solved_puzzle_dict["moves_types_history"]
        rounds_number_history = solved_puzzle_dict["rounds_number_history"]

        if ax is None:
            num_subplots = len(set_blocks_history)
            fig, ax = plt.subplots(1, num_subplots, figsize=(num_subplots * 6, 8), sharey=True, **{"squeeze": False})
            #plt.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)

        for i in range(len(set_blocks_history)):
            set_blocks = set_blocks_history[i]
            move_type = moves_types_history[i]
            position = moved_blocks_history[i]
            round = rounds_number_history[i]
            title = ""

            grid = [['white' for _ in range(grid_size[1])] for _ in range(grid_size[0])]
            for pos, block in set_blocks.items():
                row, col = pos
                grid[row][col] = block.color

            for row in range(grid_size[0]):
                for col in range(grid_size[1]):
                    color = grid[row][col]
                    rect = plt.Rectangle((col, grid_size[0] - row - 1), 1, 1, facecolor=color, edgecolor='black')
                    ax[0, i].add_patch(rect)

            if i == 0:
                title = f"..::SOLUTION::..: Solvable in {rounds_number_history[-2]} moves (blocks positions: {set_blocks})\n\nINITIAL STATE: "

            if i != len(set_blocks_history) - 1:
                title += f"(MOVE {round}) \nPerform: {move_type} at position: {position}:"
                ax[0, i], grid = BFSSolver.highlight_moved_block(set_blocks, position, ax[0, i], grid, grid_size)
                ax[0, i], grid = BFSSolver.draw_arrow(set_blocks, position, move_type, ax[0, i], grid, grid_size)
            else:
                title = "FINAL STATE"

            ax[0, i].set_aspect('equal')
            ax[0, i].axis('off')
            ax[0, i].set_xlim(-0.5, grid_size[1] + 0.5)
            ax[0, i].set_ylim(-0.5, grid_size[0] + 0.5)
            ax[0, i].set_title(title, loc='left')

        if show:
            plt.tight_layout()
            plt.show()

    @staticmethod
    def highlight_moved_block(set_blocks, position, ax, grid, grid_size):
        """
        Highlight the moved block in the plot.

        Args:
            set_blocks (dict): Current set of blocks.
            position (tuple): (row, col) of the moved block.
            ax (matplotlib.axes.Axes): Axis to plot on.
            grid (list): 2D grid of colors.
            grid_size (tuple): Size of the grid.

        Returns:
            tuple: (ax, grid)
        """
        arrow_pos_row = position[0]
        arrow_pos_col = position[1]
        color = grid[arrow_pos_row][arrow_pos_col]
        rect = plt.Rectangle((arrow_pos_col, grid_size[0] - arrow_pos_row - 1), 1, 1, facecolor=color, edgecolor='lime', linewidth=2)
        ax.add_patch(rect)
        return ax, grid

    @staticmethod
    def draw_arrow(set_blocks, position, move_type, ax, grid, grid_size):
        """
        Draw an arrow indicating the move direction.

        Args:
            set_blocks (dict): Current set of blocks.
            position (tuple): (row, col) of the moved block.
            move_type (str): Type of move.
            ax (matplotlib.axes.Axes): Axis to plot on.
            grid (list): 2D grid of colors.
            grid_size (tuple): Size of the grid.

        Returns:
            tuple: (ax, grid)
        """
        arrow_pos_row = position[0]
        arrow_pos_col = position[1]
        linecol = "lime"
        arrow = BFSSolver.create_fancy_arrow_patch(arrow_pos_col, arrow_pos_row, move_type, linecol, grid_size)
        ax.add_patch(arrow)
        return ax, grid

    @staticmethod
    def create_fancy_arrow_patch(arrow_pos_col, arrow_pos_row, move_type, linecol, grid_size):
        """
        Create a FancyArrowPatch for move visualization.

        Args:
            arrow_pos_col (int): Column of the arrow start.
            arrow_pos_row (int): Row of the arrow start.
            move_type (str): Type of move.
            linecol (str): Color of the arrow.
            grid_size (tuple): Size of the grid.

        Returns:
            FancyArrowPatch: The arrow patch object.
        """
        if move_type == "move_left":
            arrow_start = (arrow_pos_col - 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow_end = (arrow_pos_col + 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow = FancyArrowPatch(arrow_start, arrow_end, arrowstyle='<-', mutation_scale=30, linewidth=2, color=linecol)
        elif move_type == "move_right":
            arrow_start = (arrow_pos_col + 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow_end = (arrow_pos_col + 1.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow = FancyArrowPatch(arrow_start, arrow_end, arrowstyle='->', mutation_scale=30, linewidth=2, color=linecol)
        elif move_type == "exchange_left":
            arrow_start = (arrow_pos_col - 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow_end = (arrow_pos_col + 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow = FancyArrowPatch(arrow_start, arrow_end, arrowstyle='<->', mutation_scale=30, linewidth=2, color=linecol)
        elif move_type == "exchange_right":
            arrow_start = (arrow_pos_col + 0.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow_end = (arrow_pos_col + 1.5, grid_size[0] - arrow_pos_row - 0.5)
            arrow = FancyArrowPatch(arrow_start, arrow_end, arrowstyle='<->', mutation_scale=30, linewidth=2, color=linecol)
        return arrow

"""# Call the classes

Now, let's generate a lot of puzzles
"""

import datetime
import csv
import os
from matplotlib.backends.backend_pdf import PdfPages

class PuzzleBatchGenerator:
    def __init__(self, blocks_range, colors_range, colors_blocks, nb_moves, batch_grid_size, batch_stack_probability):
        self.blocks_range = blocks_range
        self.colors_range = colors_range
        self.colors = colors_blocks
        self.nb_moves = nb_moves
        self.puzzle_batch = {}
        self.nb_solvables = 0
        self.nb_unsolvables = 0
        self.stats = {}
        self.csv_data = {}
        self.batch_grid_size = batch_grid_size
        self.batch_stack_probability = batch_stack_probability

    def generate_puzzles(self):
        iterated_colors = []
        puzzle_batch = {}
        csv_data = {
            "cubes": [],
            "positions": [],
            "colors": [],
            "moves": []
        }
        stack_probability = self.batch_stack_probability
        blocks_gap = 1

        for i in range(1, nb_moves+1):
            key = 'solvable_in_' + str(i) + '_moves'
            puzzle_batch[key] = []

        for nb_colors in range(self.colors_range[0], self.colors_range[1] + 1):
            iterated_colors = self.colors[:nb_colors]
            for nb_blocks in range(self.blocks_range[0], self.blocks_range[1]+1):
                if len(iterated_colors)*3 > nb_blocks:
                    #print('Not enough blocks for the number of colors. You need at least 3 blocks per color.')
                    continue
                else:
                    if nb_colors == 1:
                        grid_size = (nb_blocks+1, nb_blocks+1)
                    else:
                        grid_size = self.batch_grid_size
                    is_solvable = False
                    print(f"Generating puzzle for {nb_blocks} blocks, {iterated_colors} colors. The size of the grid is: {grid_size}.")
                    nb_attempts = 0
                    while not(is_solvable) and nb_attempts < 5:
                        grid = GridInitializer(grid_size, nb_blocks, iterated_colors, self.nb_moves, stack_probability, blocks_gap)
                        grid.initialize_grid()
                        solver = BFSSolver(grid, PuzzleLogic())
                        is_solvable, solution = solver.perform_all_blocks_moves()
                        nb_attempts = nb_attempts + 1
                    if is_solvable:
                        round = solution["rounds_number_history"][-2]
                        key = 'solvable_in_' + str(round) + '_moves'
                        puzzle_batch[key] = puzzle_batch[key] + [(solution, grid_size)]

                        positions_list = []
                        colors_list = []

                        init_pos = solution['set_blocks_history'][0]
                        for position, block in init_pos.items():
                            positions_list.append(position)
                            color = block.get_color()
                            colors_list.append(color)

                        csv_data["cubes"] = csv_data["cubes"] + [nb_blocks]
                        csv_data["colors"] = csv_data["colors"] + [colors_list]
                        csv_data["positions"] = csv_data["positions"] + [positions_list]
                        csv_data["moves"] = csv_data["moves"] + [round]
                        self.nb_solvables = self.nb_solvables + 1
                    else:
                        self.nb_unsolvables = self.nb_unsolvables + 1

        self.puzzle_batch = puzzle_batch
        self.csv_data = csv_data
        print("Batch generation completed.")
        return self.puzzle_batch



    def print_and_save_batch(self):
        for move in sorted(self.puzzle_batch.keys()):
          list_solved_puzzles = self.puzzle_batch[move]
          for i in range(len(list_solved_puzzles)):
            solved_puzzle = list_solved_puzzles[i][0]
            grid_size = list_solved_puzzles[i][1]
            #print(f"This is the list of puzzles generated for: {move}")
            BFSSolver.print_history(solved_puzzle, grid_size, False)
        self.print_charts(False)
        filename = datetime.datetime.now().strftime("%d_%m_%Y_%H_%M_%S")+'_puzzle_generation.pdf'
        self.save_multi_image(filename)

    def save_multi_image(self, filename):
        pp = PdfPages(filename)
        fig_nums = plt.get_fignums()
        figs = [plt.figure(n) for n in fig_nums]
        for fig in figs:
          fig.savefig(pp, format='pdf')
        pp.close()
        self.save_file(filename)
        plt.show()

    def compute_stats(self): #so that we can do Pie chart, Bar chart, tables..
        for move in sorted(self.puzzle_batch.keys()):
          self.stats[move] = len(self.puzzle_batch[move])
        print("stats: ", self.stats)

    def set_batch(self, batch):
        self.puzzle_batch = batch

    def print_charts(self, show):
        labels = list(self.stats.keys()) + ['unsolvable']
        sizes = list(self.stats.values()) + [self.nb_unsolvables]

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))

        ax1.bar(labels, sizes)
        ax1.set_title('Number of Puzzles Generated (Bar Chart)')

        ax2.pie(sizes, labels=labels, autopct=lambda p: '{:.2f}%({:.0f})'.format(p,(p/100)*sum(sizes)))
        ax2.set_title('Number of Puzzles Generated (Pie Chart)')

        fig.tight_layout()

        if show:
          plt.show()

    def save_results_as_csv(self):
        filename = str(datetime.datetime.now()) + '_puzzle_generation.csv'
        fieldnames = list(self.csv_data.keys())
        with open(filename, "w", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for i in range(len(self.csv_data["cubes"])):
                writer.writerow({fieldname: self.csv_data[fieldname][i] for fieldname in fieldnames})
        self.save_file(filename)


    def save_file(self, filename):
        # Check if running in Google Colab
        if 'google.colab' in str(get_ipython()):
            from google.colab import files
            files.download(filename)
            print("Looks like we are on google colab so we file would be saved on our Kernel")
        else:
            # Save the file locally in the current working directory
            current_dir = os.getcwd()
            new_file_path = os.path.join(current_dir, filename)
            os.rename(filename, new_file_path)
            print(f"File saved locally at: {new_file_path}")

batch_generator = PuzzleBatchGenerator(blocks_range, colors_range, colors_blocks, nb_moves, batch_grid_size, stack_probability)

batch = batch_generator.generate_puzzles()

batch_generator.compute_stats()
batch_generator.print_and_save_batch()
batch_generator.save_results_as_csv()

"""Resources:
https://medium.com/swlh/solving-simplified-candy-crush-i-e-match-3-games-with-swaps-54cb7975486b
https://github.com/MohamadTarekk/EightPuzzle
https://www.youtube.com/watch?v=MQ-BffUgYfM
https://visualgo.net/en/dfsbfs
https://dev.to/lukegarrigan/what-is-bfs-breadth-first-search-nad

## Rapid tests for 1 puzzle
"""

nb_blocks = 10
colors = ['red', 'blue', 'gray']
nb_moves = 5
grid_size = (12, 12)
stack_probability = 1
blocks_gap = 1

if len(colors)*3 > nb_blocks:
  print('Not enough blocks for the number of colors. You need at least 3 blocks per color.')

grid = GridInitializer(grid_size, nb_blocks, colors, nb_moves, stack_probability, blocks_gap)
grid.initialize_grid()
#set_blocks = {(0, 1): Block("X"),(1, 1): Block("X"),(2, 1): Block("O"),(3, 1): Block("X"),(4, 1): Block("X"),(4, 3): Block("O"),(4, 4): Block("O")}
#set_blocks = {(2, 1): Block("O"), (3, 1): Block("X"), (4, 1): Block("X"),(4, 2): Block("X"), (4, 3): Block("O"), (4, 4): Block("O")}
#grid.change_set_blocks(set_blocks)
grid.print_initial_grid()

solver = BFSSolver(grid, PuzzleLogic())
is_solvable, solution = solver.perform_all_blocks_moves()
if is_solvable:
  BFSSolver.print_history(solution, solver.grid_initializer.grid_size, True)

#Pruning, optimization(Astar) and parallelisation could improve the computation